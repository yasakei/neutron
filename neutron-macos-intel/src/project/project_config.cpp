/*
 * Neutron Programming Language - Project Configuration Parser
 * Copyright (c) 2025 yasakei
 */

#include "project/project_config.h"
#include <fstream>
#include <sstream>
#include <algorithm>
#include <iostream>

namespace neutron {

std::string ProjectConfigParser::trim(const std::string& str) {
    size_t first = str.find_first_not_of(" \t\r\n");
    if (first == std::string::npos) return "";
    size_t last = str.find_last_not_of(" \t\r\n");
    return str.substr(first, (last - first + 1));
}

std::pair<std::string, std::string> ProjectConfigParser::parseLine(const std::string& line) {
    size_t pos = line.find('=');
    if (pos == std::string::npos) {
        return {"", ""};
    }
    
    std::string key = trim(line.substr(0, pos));
    std::string value = trim(line.substr(pos + 1));
    
    // Remove quotes if present
    if (value.size() >= 2 && value.front() == '"' && value.back() == '"') {
        value = value.substr(1, value.size() - 2);
    }
    
    return {key, value};
}

std::unique_ptr<ProjectConfig> ProjectConfigParser::parse(const std::string& configPath) {
    std::ifstream file(configPath);
    if (!file.is_open()) {
        return nullptr;
    }
    
    auto config = std::make_unique<ProjectConfig>();
    std::string line;
    std::string currentSection;
    
    while (std::getline(file, line)) {
        line = trim(line);
        
        // Skip empty lines and comments
        if (line.empty() || line[0] == '#') {
            continue;
        }
        
        // Check for section headers
        if (line[0] == '[' && line.back() == ']') {
            currentSection = line.substr(1, line.size() - 2);
            continue;
        }
        
        auto [key, value] = parseLine(line);
        if (key.empty()) continue;
        
        if (currentSection == "project") {
            if (key == "name") config->name = value;
            else if (key == "version") config->version = value;
            else if (key == "entry") config->entry = value;
            else if (key == "author") config->author = value;
            else if (key == "description") config->description = value;
        } else if (currentSection == "dependencies") {
            config->dependencies.push_back(key + "=" + value);
        } else {
            config->metadata[key] = value;
        }
    }
    
    file.close();
    return config;
}

bool ProjectConfigParser::save(const ProjectConfig& config, const std::string& configPath) {
    std::ofstream file(configPath);
    if (!file.is_open()) {
        return false;
    }
    
    file << "# Neutron Project Configuration\n";
    file << "# Generated by Neutron " << "\n\n";
    
    file << "[project]\n";
    file << "name = \"" << config.name << "\"\n";
    file << "version = \"" << config.version << "\"\n";
    file << "entry = \"" << config.entry << "\"\n";
    
    if (!config.author.empty()) {
        file << "author = \"" << config.author << "\"\n";
    }
    
    if (!config.description.empty()) {
        file << "description = \"" << config.description << "\"\n";
    }
    
    if (!config.dependencies.empty()) {
        file << "\n[dependencies]\n";
        for (const auto& dep : config.dependencies) {
            file << dep << "\n";
        }
    }
    
    file.close();
    return true;
}

std::unique_ptr<ProjectConfig> ProjectConfigParser::createDefault(const std::string& projectName) {
    auto config = std::make_unique<ProjectConfig>();
    config->name = projectName;
    config->version = "1.0.0";
    config->entry = "main.nt";
    config->description = "A Neutron project";
    return config;
}

} // namespace neutron
