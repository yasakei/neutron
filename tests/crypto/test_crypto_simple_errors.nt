// Simple crypto module error tests
use crypto;

say("=== Crypto Simple Error Tests ===");

var test_count = 0;
var pass_count = 0;

// Test invalid base64 decode
test_count = test_count + 1;
try {
    crypto.base64_decode("invalid!@#$");
    say("✗ base64_decode should have failed with invalid input");
} catch (e) {
    say("✓ base64_decode correctly rejected invalid input");
    pass_count = pass_count + 1;
}

// Test invalid hex decode (odd length)
test_count = test_count + 1;
try {
    crypto.hex_decode("abc"); // Odd length
    say("✗ hex_decode should have failed with odd length");
} catch (e) {
    say("✓ hex_decode correctly rejected odd length input");
    pass_count = pass_count + 1;
}

// Test invalid hex decode (invalid characters)
test_count = test_count + 1;
try {
    crypto.hex_decode("xyz123"); // Invalid characters
    say("✗ hex_decode should have failed with invalid characters");
} catch (e) {
    say("✓ hex_decode correctly rejected invalid characters");
    pass_count = pass_count + 1;
}

// Test random_bytes with invalid length
test_count = test_count + 1;
try {
    crypto.random_bytes(-1);
    say("✗ random_bytes should have failed with negative length");
} catch (e) {
    say("✓ random_bytes correctly rejected negative length");
    pass_count = pass_count + 1;
}

// Test random_bytes with zero length
test_count = test_count + 1;
try {
    crypto.random_bytes(0);
    say("✗ random_bytes should have failed with zero length");
} catch (e) {
    say("✓ random_bytes correctly rejected zero length");
    pass_count = pass_count + 1;
}

// Test random_string with negative length
test_count = test_count + 1;
try {
    crypto.random_string(-1);
    say("✗ random_string should have failed with negative length");
} catch (e) {
    say("✓ random_string correctly rejected negative length");
    pass_count = pass_count + 1;
}

// Test random_string with empty charset
test_count = test_count + 1;
try {
    crypto.random_string(10, "");
    say("✗ random_string should have failed with empty charset");
} catch (e) {
    say("✓ random_string correctly rejected empty charset");
    pass_count = pass_count + 1;
}

// Test XOR cipher with empty key
test_count = test_count + 1;
try {
    crypto.xor_cipher("data", "");
    say("✗ xor_cipher should have failed with empty key");
} catch (e) {
    say("✓ xor_cipher correctly rejected empty key");
    pass_count = pass_count + 1;
}

// Test MD5 deprecation
test_count = test_count + 1;
try {
    crypto.md5("test");
    say("✗ md5 should have failed (deprecated)");
} catch (e) {
    say("✓ md5 correctly shows deprecation error");
    pass_count = pass_count + 1;
}

say("\n=== Error Test Summary ===");
say("Tests run: " + test_count);
say("Tests passed: " + pass_count);

if (pass_count == test_count) {
    say("✓ All error handling tests passed");
} else {
    say("✗ Some error handling tests failed");
}

say("\n=== Simple Error Tests Complete ===");