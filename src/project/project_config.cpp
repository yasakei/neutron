/*
 * Neutron Programming Language
 * Copyright (c) 2026 yasakei
 * 
 * This software is distributed under the Neutron Permissive License (NPL) 1.1.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, for both open source and commercial purposes.
 * 
 * Conditions:
 * 
 * 1. The above copyright notice and this permission notice shall be included
 *    in all copies or substantial portions of the Software.
 * 
 * 2. Attribution is appreciated but NOT required.
 *    Suggested (optional) credit:
 *    "Built using Neutron Programming Language (c) yasakei"
 * 
 * 3. The name "Neutron" and the name of the copyright holder may not be used
 *    to endorse or promote products derived from this Software without prior
 *    written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


#include "project/project_config.h"
#include <fstream>
#include <sstream>
#include <algorithm>
#include <iostream>

namespace neutron {

std::string ProjectConfigParser::trim(const std::string& str) {
    size_t first = str.find_first_not_of(" \t\r\n");
    if (first == std::string::npos) return "";
    size_t last = str.find_last_not_of(" \t\r\n");
    return str.substr(first, (last - first + 1));
}

std::pair<std::string, std::string> ProjectConfigParser::parseLine(const std::string& line) {
    size_t pos = line.find('=');
    if (pos == std::string::npos) {
        return {"", ""};
    }
    
    std::string key = trim(line.substr(0, pos));
    std::string value = trim(line.substr(pos + 1));
    
    // Remove quotes if present
    if (value.size() >= 2 && value.front() == '"' && value.back() == '"') {
        value = value.substr(1, value.size() - 2);
    }
    
    return {key, value};
}

std::unique_ptr<ProjectConfig> ProjectConfigParser::parse(const std::string& configPath) {
    std::ifstream file(configPath);
    if (!file.is_open()) {
        return nullptr;
    }
    
    auto config = std::make_unique<ProjectConfig>();
    std::string line;
    std::string currentSection;
    
    while (std::getline(file, line)) {
        line = trim(line);
        
        // Skip empty lines and comments
        if (line.empty() || line[0] == '#') {
            continue;
        }
        
        // Check for section headers
        if (line[0] == '[' && line.back() == ']') {
            currentSection = line.substr(1, line.size() - 2);
            continue;
        }
        
        auto [key, value] = parseLine(line);
        if (key.empty()) continue;
        
        if (currentSection == "project") {
            if (key == "name") config->name = value;
            else if (key == "version") config->version = value;
            else if (key == "entry") config->entry = value;
            else if (key == "author") config->author = value;
            else if (key == "description") config->description = value;
        } else if (currentSection == "dependencies") {
            config->dependencies.push_back(key + "=" + value);
        } else {
            config->metadata[key] = value;
        }
    }
    
    file.close();
    return config;
}

bool ProjectConfigParser::save(const ProjectConfig& config, const std::string& configPath) {
    std::ofstream file(configPath);
    if (!file.is_open()) {
        return false;
    }
    
    file << "# Neutron Project Configuration\n";
    file << "# Generated by Neutron " << "\n\n";
    
    file << "[project]\n";
    file << "name = \"" << config.name << "\"\n";
    file << "version = \"" << config.version << "\"\n";
    file << "entry = \"" << config.entry << "\"\n";
    
    if (!config.author.empty()) {
        file << "author = \"" << config.author << "\"\n";
    }
    
    if (!config.description.empty()) {
        file << "description = \"" << config.description << "\"\n";
    }
    
    if (!config.dependencies.empty()) {
        file << "\n[dependencies]\n";
        for (const auto& dep : config.dependencies) {
            file << dep << "\n";
        }
    }
    
    file.close();
    return true;
}

std::unique_ptr<ProjectConfig> ProjectConfigParser::createDefault(const std::string& projectName) {
    auto config = std::make_unique<ProjectConfig>();
    config->name = projectName;
    config->version = "1.0.0";
    config->entry = "main.nt";
    config->description = "A Neutron project";
    return config;
}

} // namespace neutron
