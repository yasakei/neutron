/*
 * Neutron Programming Language
 * Copyright (c) 2026 yasakei
 * 
 * This software is distributed under the Neutron Permissive License (NPL) 1.1.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, for both open source and commercial purposes.
 * 
 * Conditions:
 * 
 * 1. The above copyright notice and this permission notice shall be included
 *    in all copies or substantial portions of the Software.
 * 
 * 2. Attribution is appreciated but NOT required.
 *    Suggested (optional) credit:
 *    "Built using Neutron Programming Language (c) yasakei"
 * 
 * 3. The name "Neutron" and the name of the copyright holder may not be used
 *    to endorse or promote products derived from this Software without prior
 *    written permission.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */


#include "project/project_manager.h"
#include "project/project_config.h"
#include "types/version.h"
#include <iostream>
#include <fstream>
#include <filesystem>
#include <cstdlib>
#include <algorithm>

#ifdef _WIN32
#include <direct.h>
#define getcwd _getcwd
#else
#include <unistd.h>
#endif

namespace neutron {

std::string ProjectManager::getCurrentDirectory() {
    char buffer[FILENAME_MAX];
    if (getcwd(buffer, sizeof(buffer))) {
        return std::string(buffer);
    }
    return ".";
}

bool ProjectManager::createDirectory(const std::string& path) {
    try {
        return std::filesystem::create_directories(path);
    } catch (...) {
        return false;
    }
}

bool ProjectManager::fileExists(const std::string& path) {
    return std::filesystem::exists(path) && std::filesystem::is_regular_file(path);
}

bool ProjectManager::directoryExists(const std::string& path) {
    return std::filesystem::exists(path) && std::filesystem::is_directory(path);
}

int ProjectManager::executeCommand(const std::string& command) {
    return system(command.c_str());
}

std::string ProjectManager::getBoxPath(const std::string& projectRoot) {
    return projectRoot + "/deps/nt-box/box";
}

bool ProjectManager::isNeutronProject(const std::string& path) {
    std::string configPath = path + "/.quark";
    return fileExists(configPath);
}

std::string ProjectManager::findProjectRoot(const std::string& startPath) {
    std::filesystem::path current = std::filesystem::absolute(startPath);
    
    while (true) {
        std::string configPath = current.string() + "/.quark";
        if (fileExists(configPath)) {
            return current.string();
        }
        
        if (!current.has_parent_path() || current == current.parent_path()) {
            break;
        }
        
        current = current.parent_path();
    }
    
    return "";
}

std::unique_ptr<ProjectConfig> ProjectManager::loadConfig(const std::string& projectRoot) {
    std::string configPath = projectRoot + "/.quark";
    return ProjectConfigParser::parse(configPath);
}

bool ProjectManager::initProject(const std::string& projectName) {
    std::string currentDir = getCurrentDirectory();
    
    // Check if already a project
    if (isNeutronProject(currentDir)) {
        std::cerr << "Error: This directory is already a Neutron project (.quark exists)" << std::endl;
        return false;
    }
    
    // Get project name
    std::string name = projectName;
    if (name.empty()) {
        // Use directory name as project name
        std::filesystem::path dirPath(currentDir);
        name = dirPath.filename().string();
    }
    
    std::cout << "Initializing Neutron project: " << name << std::endl;
    
    // Create project config
    auto config = ProjectConfigParser::createDefault(name);
    
    // Save .quark file
    std::string configPath = currentDir + "/.quark";
    if (!ProjectConfigParser::save(*config, configPath)) {
        std::cerr << "Error: Failed to create .quark configuration file" << std::endl;
        return false;
    }
    
    // Create main.nt if it doesn't exist
    std::string mainFile = currentDir + "/main.nt";
    if (!fileExists(mainFile)) {
        std::ofstream file(mainFile);
        if (file.is_open()) {
            file << "// " << name << " - Neutron Project\n";
            file << "// Generated by Neutron " << Version::getVersion() << "\n\n";
            file << "say(\"Hello from " << name << "!\");\n";
            file.close();
            std::cout << "Created: main.nt" << std::endl;
        }
    }
    
    // Create build directory
    std::string buildDir = currentDir + "/build";
    if (!directoryExists(buildDir)) {
        createDirectory(buildDir);
        std::cout << "Created: build/" << std::endl;
    }
    
    // Create .box directory for modules
    std::string boxDir = currentDir + "/.box";
    if (!directoryExists(boxDir)) {
        createDirectory(boxDir);
        createDirectory(boxDir + "/modules");
        std::cout << "Created: .box/modules/" << std::endl;
    }
    
    // Create bin directory for local tools
    std::string binDir = currentDir + "/bin";
    if (!directoryExists(binDir)) {
        createDirectory(binDir);
        std::cout << "Created: bin/" << std::endl;
    }
    
    // Create .gitignore if it doesn't exist
    std::string gitignorePath = currentDir + "/.gitignore";
    if (!fileExists(gitignorePath)) {
        std::ofstream file(gitignorePath);
        if (file.is_open()) {
            file << "# Neutron build artifacts\n";
            file << "build/\n";
            file << "deps/\n";
            file << "!deps/activate_env\n";
            file << ".box/\n";
            file << "bin/\n";
            file << "*.out\n";
            file.close();
            std::cout << "Created: .gitignore" << std::endl;
        }
    }
    
    // Create deps directory for dependencies
    std::string depsDir = currentDir + "/deps";
    if (!directoryExists(depsDir)) {
        createDirectory(depsDir);
        std::cout << "Created: deps/" << std::endl;
    }
    
    // Create activate_env script for environment management
    std::string activatePath = depsDir + "/activate_env";
    if (!fileExists(activatePath)) {
        std::ofstream file(activatePath);
        if (file.is_open()) {
            file << "#!/bin/bash\n";
            file << "# Neutron Project Environment Activation Script\n";
            file << "# Usage: source deps/activate_env\n\n";
            file << "# Store original PATH\n";
            file << "export NEUTRON_OLD_PATH=\"$PATH\"\n\n";
            file << "# Add project bin to PATH\n";
            file << "export PATH=\"$PWD/bin:$PATH\"\n\n";
            file << "# Create deactivate function\n";
            file << "deactivate() {\n";
            file << "    export PATH=\"$NEUTRON_OLD_PATH\"\n";
            file << "    unset NEUTRON_OLD_PATH\n";
            file << "    unset -f deactivate\n";
            file << "    echo \"Neutron environment deactivated\"\n";
            file << "}\n\n";
            file << "echo \"Neutron environment activated\"\n";
            file << "echo \"You can now use: box install <module>\"\n";
            file << "echo \"To deactivate, run: deactivate\"\n";
            file.close();
            
            // Make it executable on Unix
#ifndef _WIN32
            std::string chmodCmd = "chmod +x \"" + activatePath + "\"";
            executeCommand(chmodCmd);
#endif
            std::cout << "Created: deps/activate_env" << std::endl;
        }
    }
    
    std::cout << "\n✓ Project initialized successfully!" << std::endl;
    std::cout << "\nNext steps:" << std::endl;
    std::cout << "  1. Activate the environment: source deps/activate_env" << std::endl;
    std::cout << "  2. Install Box (optional): neutron install box" << std::endl;
    std::cout << "  3. Edit main.nt to add your code" << std::endl;
    std::cout << "  4. Run: neutron run" << std::endl;
    std::cout << "  5. Build: neutron build" << std::endl;
    std::cout << "\nWith activated environment, you can use: box install <module>" << std::endl;
    
    return true;
}

bool ProjectManager::runProject(const std::string& projectRoot) {
    // Find project root if not specified
    std::string root = projectRoot;
    if (root == ".") {
        root = findProjectRoot(getCurrentDirectory());
        if (root.empty()) {
            std::cerr << "Error: Not in a Neutron project. Run './neutron init' to create one." << std::endl;
            return false;
        }
    }
    
    // Load config
    auto config = loadConfig(root);
    if (!config) {
        std::cerr << "Error: Failed to load project configuration" << std::endl;
        return false;
    }
    
    // Check if entry file exists
    std::string entryFile = root + "/" + config->entry;
    if (!fileExists(entryFile)) {
        std::cerr << "Error: Entry file not found: " << config->entry << std::endl;
        return false;
    }
    
    std::cout << "Running: " << config->name << " v" << config->version << std::endl;
    std::cout << "Entry: " << config->entry << "\n" << std::endl;
    
    // This will be handled by main.cpp - return the entry file path
    return true;
}

bool ProjectManager::buildProject(const std::string& projectRoot) {
    // Find project root if not specified
    std::string root = projectRoot;
    if (root == ".") {
        root = findProjectRoot(getCurrentDirectory());
        if (root.empty()) {
            std::cerr << "Error: Not in a Neutron project. Run './neutron init' to create one." << std::endl;
            return false;
        }
    }
    
    // Load config
    auto config = loadConfig(root);
    if (!config) {
        std::cerr << "Error: Failed to load project configuration" << std::endl;
        return false;
    }
    
    // Check if entry file exists
    std::string entryFile = root + "/" + config->entry;
    if (!fileExists(entryFile)) {
        std::cerr << "Error: Entry file not found: " << config->entry << std::endl;
        return false;
    }
    
    std::cout << "Building: " << config->name << " v" << config->version << std::endl;
    std::cout << "Entry: " << config->entry << std::endl;
    
    // Create build directory
    std::string buildDir = root + "/build";
    createDirectory(buildDir);
    
    // Output executable name
    std::string outputName = config->name;
#ifdef _WIN32
    outputName += ".exe";
#endif
    std::string outputPath = buildDir + "/" + outputName;
    
    std::cout << "Output: " << outputPath << "\n" << std::endl;
    
    // This will be handled by main.cpp using the existing binary compilation
    return true;
}

bool ProjectManager::installBox(const std::string& projectRoot) {
    // Find project root if not specified
    std::string root = projectRoot;
    if (root == ".") {
        root = findProjectRoot(getCurrentDirectory());
        if (root.empty()) {
            std::cerr << "Error: Not in a Neutron project. Run './neutron init' to create one." << std::endl;
            return false;
        }
    }
    
    std::cout << "Installing Box package manager..." << std::endl;
    
    // Check if git is installed
    if (executeCommand("git --version >nul 2>nul") != 0 && executeCommand("git --version >/dev/null 2>&1") != 0) {
        std::cerr << "Error: 'git' command not found." << std::endl;
        std::cerr << "Please install Git to continue:" << std::endl;
        #ifdef _WIN32
        std::cerr << "  Download from https://git-scm.com/download/win" << std::endl;
        #else
        std::cerr << "  Ubuntu/Debian: sudo apt install git" << std::endl;
        std::cerr << "  macOS: brew install git" << std::endl;
        #endif
        return false;
    }
    
    // Create deps directory
    std::string depsDir = root + "/deps";
    if (!directoryExists(depsDir)) {
        createDirectory(depsDir);
        std::cout << "Created: deps/" << std::endl;
    }
    
    // Check if Box source is already present
    std::string boxSourceDir = depsDir + "/nt-box";
    if (directoryExists(boxSourceDir)) {
        std::cout << "Box source found. Updating..." << std::endl;
        // Update existing installation
        std::string updateCmd = "cd \"" + boxSourceDir + "\" && git pull";
        if (executeCommand(updateCmd) != 0) {
            std::cerr << "Warning: Failed to update Box repository" << std::endl;
        }
    } else {
        // Clone Box repository
        std::cout << "Cloning Box repository from https://github.com/yasakei/nt-box..." << std::endl;
        std::string cloneCmd = "git clone https://github.com/yasakei/nt-box.git \"" + boxSourceDir + "\"";
        if (executeCommand(cloneCmd) != 0) {
            std::cerr << "Error: Failed to clone Box repository" << std::endl;
            std::cerr << "Make sure git is installed and you have internet connection" << std::endl;
            return false;
        }
    }
    
    // Build Box for the current platform
    std::cout << "\nBuilding Box for your platform..." << std::endl;
    
#ifdef _WIN32
    std::string buildCmd = "cd \"" + boxSourceDir + "\" && mkdir build 2>nul && cd build && cmake .. && cmake --build . --config Release";
#else
    std::string buildCmd = "cd \"" + boxSourceDir + "\" && mkdir -p build && cd build && cmake .. && make -j$(nproc 2>/dev/null || echo 4)";
#endif
    
    if (executeCommand(buildCmd) != 0) {
        std::cerr << "Error: Failed to build Box" << std::endl;
        std::cerr << "Make sure CMake and a C++ compiler are installed" << std::endl;
        return false;
    }
    
    // Find the built binary
    std::string builtBinaryPath;
#ifdef _WIN32
    if (fileExists(boxSourceDir + "/build/Release/box.exe")) builtBinaryPath = boxSourceDir + "/build/Release/box.exe";
    else if (fileExists(boxSourceDir + "/build/box.exe")) builtBinaryPath = boxSourceDir + "/build/box.exe";
#else
    if (fileExists(boxSourceDir + "/build/box")) builtBinaryPath = boxSourceDir + "/build/box";
#endif

    if (builtBinaryPath.empty()) {
        std::cerr << "Error: Box executable not found after build" << std::endl;
        return false;
    }
    
    // Create deps/box directory
    std::string boxInstallDir = depsDir + "/box";
    
    // Ensure deps/box is a directory
    if (fileExists(boxInstallDir) && !directoryExists(boxInstallDir)) {
        std::filesystem::remove(boxInstallDir);
    }
    if (!directoryExists(boxInstallDir)) {
        createDirectory(boxInstallDir);
    }
    
    // Copy binary to deps/box/
    std::string installedBoxPath = boxInstallDir + "/box";
#ifdef _WIN32
    installedBoxPath += ".exe";
    std::string copyInstallCmd = "copy /Y \"" + builtBinaryPath + "\" \"" + installedBoxPath + "\"";
#else
    std::string copyInstallCmd = "cp -f \"" + builtBinaryPath + "\" \"" + installedBoxPath + "\"";
#endif
    
    std::cout << "Copying " << builtBinaryPath << " to " << installedBoxPath << std::endl;
    if (executeCommand(copyInstallCmd) != 0) {
        std::cerr << "Error: Failed to copy Box binary" << std::endl;
        // Fallback: try to copy using filesystem
        try {
            std::filesystem::copy_file(builtBinaryPath, installedBoxPath, std::filesystem::copy_options::overwrite_existing);
        } catch (const std::exception& e) {
             std::cerr << "Filesystem copy also failed: " << e.what() << std::endl;
             return false;
        }
    }
    
    // Create local bin directory for easy access
    std::string binDir = root + "/bin";
    if (!directoryExists(binDir)) {
        createDirectory(binDir);
    }
    
    // Create symlink or copy box to bin/
    std::string localBoxPath = binDir + "/box";
#ifdef _WIN32
    localBoxPath += ".exe";
    // On Windows, copy the executable
    std::string copyCmd = "copy /Y \"" + installedBoxPath + "\" \"" + localBoxPath + "\"";
    executeCommand(copyCmd);
#else
    // On Unix, create a symlink
    // Remove existing link/file first
    std::filesystem::remove(localBoxPath);
    // Use relative path for symlink if possible, or absolute
    std::string symlinkCmd = "ln -sf \"../deps/box/box\" \"" + localBoxPath + "\"";
    executeCommand(symlinkCmd);
#endif
    
    // Make box executable on Unix
#ifndef _WIN32
    std::string chmodCmd = "chmod +x \"" + installedBoxPath + "\"";
    executeCommand(chmodCmd);
    // Symlink inherits permissions, but good to ensure source is executable
#endif
    
    std::cout << "\n✓ Box installed successfully!" << std::endl;
    std::cout << "Location: " << installedBoxPath << std::endl;
    std::cout << "Linked to: " << localBoxPath << std::endl;
    std::cout << "\nYou can now use Box to install modules:" << std::endl;
    std::cout << "  ./bin/box install <module-name>" << std::endl;
    
    return true;
}

} // namespace neutron
