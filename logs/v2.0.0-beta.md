# Neutron v2.0.0-beta Release Notes

**Release Date:** November 27, 2025  
**Version:** 2.0.0-beta

## üéâ Major Features

### Selective Imports

The headline feature of v2.0.0 is **selective imports** - a powerful new way to import only the symbols you need from modules and files.

#### Syntax

```neutron
// Import specific functions from a module
use (now, sleep) = from time;

// Import specific functions from a file
using (hello, goodbye) = from "mylib.nt";
```

#### Benefits

- **Namespace Clarity**: Only import what you need, making dependencies explicit
- **Avoid Conflicts**: Prevent name collisions when importing from multiple sources
- **Better Performance**: Smaller global scope means faster lookups
- **Explicit Dependencies**: Clear which symbols come from which module

#### Examples

**From Modules:**
```neutron
use (now, sleep) = from time;

say(now());    // Available
sleep(100);    // Available
// format() is NOT available
```

**From Files:**

`math_helpers.nt`:
```neutron
fun add(a, b) { return a + b; }
fun subtract(a, b) { return a - b; }
fun multiply(a, b) { return a * b; }
```

`main.nt`:
```neutron
using (add, multiply) = from "math_helpers.nt";

say(add(5, 3));      // Works: 8
say(multiply(4, 2)); // Works: 8
say(subtract(5, 2)); // Error: undefined variable
```

#### Implementation Details

- **Scanner**: Added `FROM` keyword token
- **Parser**: Updated `useStatement()` to parse `(symbol1, symbol2) = from source` syntax
- **AST**: Extended `UseStmt` with `std::vector<Token> importedSymbols`
- **VM**: 
  - Implemented `load_file_as_module()` to load files into isolated environments
  - Implemented `interpret_module()` to execute code in isolated scope
  - Module environment captures only symbols defined in that module
- **Compiler**: Updated `visitUseStmt()` to selectively import symbols into global scope
- **Value**: Added `isModule()` and `asModule()` helper methods

## üîß Critical Fixes

### File Embedding in Built Projects

**Problem:** Files imported via `using "filename.nt"` were not included in binaries built with `neutron build`. The built executable would fail if these files were not present at runtime.

**Solution:**
- Added `VM::addEmbeddedFile()` to store file content in memory
- Updated `VM::load_file()` to check embedded files before disk access
- Modified `ProjectBuilder` to recursively scan for `using` statements
- Embedded file content as C-style string literals in generated C++ code

**Result:** Executables are now truly standalone - no external .nt files needed!

### Static Type Annotations

Neutron now supports **optional static type annotations** for variables, providing self-documenting code and runtime type safety.

#### Syntax

```neutron
var int count = 42;
var string name = "Alice";
var bool isActive = true;
var array numbers = [1, 2, 3];
var object config = {"key": "value"};
var any value = "anything";  // Accepts any type
```

#### Available Types

- `int` - Integer numbers
- `float` - Floating-point numbers
- `string` - Text strings
- `bool` - Boolean values
- `array` - Arrays
- `object` - Objects
- `any` - Any type (no restriction)

#### Features

- **Optional**: You can mix typed and untyped variables
- **Runtime Checking**: Type mismatches are caught at runtime
- **Self-Documenting**: Makes code intent clearer
- **Future-Proof**: Enables potential static analysis and IDE support

#### Example

```neutron
var int x = 42;
x = "hello";  // Runtime error: Type mismatch

var string name = "Alice";
name = 123;   // Runtime error: Type mismatch

var any flexible = 42;
flexible = "hello";  // OK - 'any' accepts all types
```

### Quark Project System

The **Quark project system** is a complete project management solution for Neutron, making it easy to create, build, and distribute Neutron applications.

#### Commands

```bash
# Initialize a new project
neutron init myproject
cd myproject

# Run the project
neutron run

# Build standalone executable
neutron build
```

#### Project Structure

```
myproject/
‚îú‚îÄ‚îÄ .quark              # Project configuration
‚îú‚îÄ‚îÄ main.nt            # Entry point
‚îú‚îÄ‚îÄ lib/               # Local libraries (optional)
‚îú‚îÄ‚îÄ .box/              # Box modules (optional)
‚îÇ   ‚îî‚îÄ‚îÄ modules/
‚îî‚îÄ‚îÄ build/             # Build output
    ‚îî‚îÄ‚îÄ myproject      # Standalone executable
```

#### Configuration (.quark)

```toml
[project]
name = "myproject"
version = "1.0.0"
entry = "main.nt"
description = "My Neutron project"
```

#### Features

- **Automatic Dependency Detection**: Finds and links all required modules
- **Native Module Integration**: Quark modules in `libs/` are automatically compiled and linked
- **Box Module Support**: External modules from `.box/modules/` are linked as shared libraries
- **Resource Embedding**: All `using` imports are embedded in the final executable
- **Cross-Platform**: Builds work on Linux, macOS, and Windows
- **Standalone Executables**: No runtime dependencies on .nt files

#### Build Process

1. Reads `.quark` configuration
2. Scans entry file for dependencies
3. Recursively finds all `using` imports
4. Detects Quark modules (native C++ in `libs/`)
5. Detects Box modules (external in `.box/modules/`)
6. Generates C++ wrapper with embedded resources
7. Compiles with CMake
8. Links all dependencies
9. Produces standalone executable in `build/`

**Example:**
```bash
# Build project with imports
neutron build

# Move executable to clean directory
mv build/myproject /tmp/
cd /tmp

# Runs successfully without source files!
./myproject
```

### Box Module Shared Library Linking

**Problem:** `neutron build` failed for projects using Box modules because the build system looked for `native.cpp` source files, but Box modules provide pre-compiled shared libraries (`.so`, `.dylib`, `.dll`).

**Solution:**
- Updated `ProjectBuilder::findBoxModules()` to detect shared library files
- Modified build command generation to link shared libraries using `-L`, `-l`, and `-rpath` flags
- Proper runtime path configuration for Linux/macOS

**Result:** Box modules with shared libraries now link correctly into built executables.

## üìä Test Suite

- **Total Tests:** 56 (all passing ‚úÖ)
- **New Test:** `tests/core/test_selective_import.nt`
  - Single function import from module
  - Single function import from file
  - Multiple function imports
  - Isolation verification (non-imported symbols unavailable)

## üìö Documentation Updates

### Language Reference
- Added comprehensive selective imports section
- Syntax examples and use cases
- Benefits and best practices

### Module System Guide
- Detailed selective imports documentation
- Comparison between traditional and selective imports
- Real-world examples


## üîÑ Migration Guide

### From v1.x to v2.0

**Selective Imports (Optional):**

Old way (still works):
```neutron
use time;
time.now();
time.sleep(100);
```

New way (recommended for clarity):
```neutron
use (now, sleep) = from time;
now();
sleep(100);
```

**No Breaking Changes:**
- All existing code continues to work
- Selective imports are opt-in
- Traditional imports still fully supported

## üèóÔ∏è Technical Architecture

### Selective Import Flow

1. **Parse Time:**
   - Parser detects `(symbols) = from source` syntax
   - Creates `UseStmt` with `importedSymbols` list

2. **Compile Time:**
   - Compiler checks if `importedSymbols` is empty
   - For selective imports:
     - Load module/file into isolated environment
     - Extract requested symbols
     - Define only those symbols in current scope

3. **Runtime:**
   - Module environment contains all symbols from that module
   - Only requested symbols are accessible in importing scope

### File Embedding Flow

1. **Build Time:**
   - Scan main source file for `using` statements
   - Recursively find all imported files
   - Read file contents
   - Embed as C-style string literals in generated C++
   - Register with `vm.addEmbeddedFile()`

2. **Runtime:**
   - `load_file()` checks `embeddedFiles` map first
   - Falls back to disk if not found
   - Supports nested imports seamlessly

## üéØ Version Numbering

- **Major Version Bump:** 1.x ‚Üí 2.0
- **Reason:** Significant new feature (selective imports)
- **Stability:** Beta (feature-complete, production-ready)

## üêõ Known Issues

See `docs/implementation/known-issues.md` for complete list.

**Notable:**
- Box Package Manager has Windows compatibility issues (workaround: use WSL)
- Not-equal operator (!=) has known issues (workaround: use `==` with negation)

## üôè Acknowledgments

This release represents a significant milestone in Neutron's evolution, bringing Python-like selective imports to a compiled language with true standalone executables.

## üì¶ Installation

```bash
# Download release
wget https://github.com/yasakei/neutron/releases/download/v2.0.0-beta/neutron-v2.0.0-beta-linux-x64.tar.gz

# Extract
tar -xzf neutron-v2.0.0-beta-linux-x64.tar.gz

# Install
cd neutron-v2.0.0-beta
sudo ./install.sh
```

## üîó Links

- [Documentation](https://github.com/yasakei/neutron/tree/main/docs)
- [Language Reference](https://github.com/yasakei/neutron/blob/main/docs/reference/language_reference.md)
- [Module System](https://github.com/yasakei/neutron/blob/main/docs/reference/module-system.md)
- [Known Issues](https://github.com/yasakei/neutron/blob/main/docs/implementation/known-issues.md)

---

**Full Changelog:** https://github.com/yasakei/neutron/blob/main/CHANGELOG.md
